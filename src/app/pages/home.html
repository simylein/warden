<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="description" content="View key statistics of your devices" />
		<title>Warden home</title>
		<style></style>
	</head>
	<body
		class="font-sans min-h-dvh flex flex-col m-0 text-base leading-none text-black dark:text-white background-white dark:background-black scheme-light-dark"
		onload="
			loadReadings();
			loadMetrics();
			loadBuffers();
		"
	>
		<header class="sticky top-0 w-full background-neutral-100 dark:background-neutral-900 z-4">
			<div class="flex items-center justify-between gap-4 sm:gap-6 lg:gap-8 pr-4 sm:pr-6 lg:pr-8 pl-4 sm:pl-6 lg:pl-8">
				<nav class="flex flex-row gap-2 sm:gap-3 lg:gap-4 pt-2 sm:pt-3 lg:pt-4 pb-2 sm:pb-3 lg:pb-4 text-lg font-normal overflow-x-auto scrollbar-none">
					<a href="/" class="no-underline text-blue-600 dark:text-blue-400">Home</a>
					<a href="/devices" class="no-underline text-black dark:text-white">Devices</a>
					<a href="/zones" class="no-underline text-black dark:text-white">Zones</a>
					<a href="/uplinks" class="no-underline text-black dark:text-white">Uplinks</a>
					<a href="/downlinks" class="no-underline text-black dark:text-white">Downlinks</a>
					<a href="/users" class="no-underline text-black dark:text-white">Users</a>
				</nav>
				<a href="/profile" class="flex text-black dark:text-white">
					<icon-user ref="./src/app/components/icon-user.html" class="w-5 lg:w-6 h-5 lg:h-6" />
				</a>
			</div>
		</header>
		<main class="flex flex-col grow gap-2 sm:gap-3 lg:gap-4 m-4 sm:m-6 lg:m-8">
			<div class="flex flex-col lg:flex-row items-start lg:items-center justify-between gap-2 sm:gap-3 lg:gap-4 overflow-x-auto scrollbar-none">
				<filter-ranges ref="./src/app/components/filter-ranges.html" id="ranges" />
				<filter-times ref="./src/app/components/filter-times.html" id="times" />
			</div>
			<div class="p-2 sm:p-3 lg:p-4 background-neutral-100 dark:background-neutral-900">
				<div class="flex justify-between gap-2 mb-1 sm:mb-2">
					<h2 class="m-0 text-base font-normal">Temperature</h2>
					<p id="temperature-range" class="m-0 w-28 h-4 background-neutral-200 dark:background-neutral-800"><span></span><span></span><span></span></p>
				</div>
				<div class="overflow-x-auto scrollbar-none">
					<graph-guide ref="./src/app/components/graph-guide.html" id="temperature-guide" />
				</div>
				<div style="grid-template-columns: auto 1fr; grid-template-rows: auto auto" class="grid gap-1 sm:gap-2">
					<graph-scale ref="./src/app/components/graph-scale.html" id="temperature-scale" />
					<div class="relative flex flex-col">
						<svg id="temperature-graph" class="absolute w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
							<path ref="./src/app/components/graph-temperature-path.html" />
							<path ref="./src/app/components/graph-multi-paths.html" />
						</svg>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
					</div>
					<div></div>
					<graph-label ref="./src/app/components/graph-label.html" id="temperature-label" />
				</div>
			</div>
			<div class="p-2 sm:p-3 lg:p-4 background-neutral-100 dark:background-neutral-900">
				<div class="flex justify-between gap-2 mb-1 sm:mb-2">
					<h2 class="m-0 text-base font-normal">Humidity</h2>
					<p id="humidity-range" class="m-0 w-28 h-4 background-neutral-200 dark:background-neutral-800"><span></span><span></span><span></span></p>
				</div>
				<div class="overflow-x-auto scrollbar-none">
					<graph-guide ref="./src/app/components/graph-guide.html" id="humidity-guide" />
				</div>
				<div style="grid-template-columns: auto 1fr; grid-template-rows: auto auto" class="grid gap-1 sm:gap-2">
					<graph-scale ref="./src/app/components/graph-scale.html" id="humidity-scale" />
					<div class="relative flex flex-col">
						<svg id="humidity-graph" class="absolute w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
							<path ref="./src/app/components/graph-humidity-path.html" />
							<path ref="./src/app/components/graph-multi-paths.html" />
						</svg>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
					</div>
					<div></div>
					<graph-label ref="./src/app/components/graph-label.html" id="humidity-label" />
				</div>
			</div>
			<div class="p-2 sm:p-3 lg:p-4 background-neutral-100 dark:background-neutral-900">
				<div class="flex justify-between gap-2 mb-1 sm:mb-2">
					<h2 class="m-0 text-base font-normal">Photovoltaic</h2>
					<p id="photovoltaic-range" class="m-0 w-28 h-4 background-neutral-200 dark:background-neutral-800"><span></span><span></span><span></span></p>
				</div>
				<div class="overflow-x-auto scrollbar-none">
					<graph-guide ref="./src/app/components/graph-guide.html" id="photovoltaic-guide" />
				</div>
				<div style="grid-template-columns: auto 1fr; grid-template-rows: auto auto" class="grid gap-1 sm:gap-2">
					<graph-scale ref="./src/app/components/graph-scale.html" id="photovoltaic-scale" />
					<div class="relative flex flex-col">
						<svg id="photovoltaic-graph" class="absolute w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
							<path ref="./src/app/components/graph-photovoltaic-path.html" />
							<path ref="./src/app/components/graph-multi-paths.html" />
						</svg>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
					</div>
					<div></div>
					<graph-label ref="./src/app/components/graph-label.html" id="photovoltaic-label" />
				</div>
			</div>
			<div class="p-2 sm:p-3 lg:p-4 background-neutral-100 dark:background-neutral-900">
				<div class="flex justify-between gap-2 mb-1 sm:mb-2">
					<h2 class="m-0 text-base font-normal">Battery</h2>
					<p id="battery-range" class="m-0 w-28 h-4 background-neutral-200 dark:background-neutral-800"><span></span><span></span><span></span></p>
				</div>
				<div class="overflow-x-auto scrollbar-none">
					<graph-guide ref="./src/app/components/graph-guide.html" id="battery-guide" />
				</div>
				<div style="grid-template-columns: auto 1fr; grid-template-rows: auto auto" class="grid gap-1 sm:gap-2">
					<graph-scale ref="./src/app/components/graph-scale.html" id="battery-scale" />
					<div class="relative flex flex-col">
						<svg id="battery-graph" class="absolute w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
							<path ref="./src/app/components/graph-battery-path.html" />
							<path ref="./src/app/components/graph-multi-paths.html" />
						</svg>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
					</div>
					<div></div>
					<graph-label ref="./src/app/components/graph-label.html" id="battery-label" />
				</div>
			</div>
			<div class="p-2 sm:p-3 lg:p-4 background-neutral-100 dark:background-neutral-900">
				<div class="flex justify-between gap-2 mb-1 sm:mb-2">
					<h2 class="m-0 text-base font-normal">Delay</h2>
					<p id="delay-range" class="m-0 w-28 h-4 background-neutral-200 dark:background-neutral-800"><span></span><span></span><span></span></p>
				</div>
				<div class="overflow-x-auto scrollbar-none">
					<graph-guide ref="./src/app/components/graph-guide.html" id="delay-guide" />
				</div>
				<div style="grid-template-columns: auto 1fr; grid-template-rows: auto auto" class="grid gap-1 sm:gap-2">
					<graph-scale ref="./src/app/components/graph-scale.html" id="delay-scale" />
					<div class="relative flex flex-col">
						<svg id="delay-graph" class="absolute w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
							<path ref="./src/app/components/graph-delay-path.html" />
							<path ref="./src/app/components/graph-multi-paths.html" />
						</svg>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
					</div>
					<div></div>
					<graph-label ref="./src/app/components/graph-label.html" id="delay-label" />
				</div>
			</div>
			<div class="p-2 sm:p-3 lg:p-4 background-neutral-100 dark:background-neutral-900">
				<div class="flex justify-between gap-2 mb-1 sm:mb-2">
					<h2 class="m-0 text-base font-normal">Level</h2>
					<p id="level-range" class="m-0 w-28 h-4 background-neutral-200 dark:background-neutral-800"><span></span><span></span><span></span></p>
				</div>
				<div class="overflow-x-auto scrollbar-none">
					<graph-guide ref="./src/app/components/graph-guide.html" id="level-guide" />
				</div>
				<div style="grid-template-columns: auto 1fr; grid-template-rows: auto auto" class="grid gap-1 sm:gap-2">
					<graph-scale ref="./src/app/components/graph-scale.html" id="level-scale" />
					<div class="relative flex flex-col">
						<svg id="level-graph" class="absolute w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
							<path ref="./src/app/components/graph-level-path.html" />
							<path ref="./src/app/components/graph-multi-paths.html" />
						</svg>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
						<span class="box-border h-8 border-0 border-b-1 border-solid border-neutral-300 dark:border-neutral-600"></span>
					</div>
					<div></div>
					<graph-label ref="./src/app/components/graph-label.html" id="level-label" />
				</div>
			</div>
		</main>
		<footer class="w-full background-neutral-100 dark:background-neutral-900">
			<div
				class="flex flex-row justify-between gap-2 sm:gap-3 lg:gap-4 pt-2 sm:pt-3 lg:pt-4 pr-4 sm:pr-6 lg:pr-8 pb-2 sm:pb-3 lg:pb-4 pl-4 sm:pl-6 lg:pl-8 text-lg font-normal text-nowrap overflow-x-auto scrollbar-none"
			>
				<p class="m-0 text-xs font-normal text-neutral-400 dark:text-neutral-600">warden {version} {commit}</p>
				<p class="m-0 text-xs font-normal text-neutral-400 dark:text-neutral-600">written by simylein</p>
			</div>
		</footer>
	</body>
	<script>
		import './src/app/scripts/duration.js';
		import './src/app/scripts/breakpoint.js';
		import './src/app/scripts/datetime.js';
		import './src/app/scripts/timespan.js';
		import './src/app/scripts/array.js';
		import './src/app/scripts/state.js';
		import './src/app/scripts/math.js';
		import './src/app/scripts/graph.js';
		import './src/app/scripts/skeleton-reading.js';
		import './src/app/scripts/skeleton-metric.js';
		import './src/app/scripts/skeleton-buffer.js';
		import './src/app/scripts/fade.js';
		import './src/app/scripts/color-reading.js';
		import './src/app/scripts/color-metric.js';
		import './src/app/scripts/color-buffer.js';
		import './src/app/scripts/search.js';
		import './src/app/scripts/binary.js';
		import './src/app/scripts/fetcher.js';
		import './src/app/scripts/fetching.js';
		const ranges = document.getElementById('ranges');
		const times = document.getElementById('times');
		const readings = { retries: 0, reload: null, timeout: null, controller: null, data: null, width: null };
		const metrics = { retries: 0, reload: null, timeout: null, controller: null, data: null, width: null };
		const buffers = { retries: 0, reload: null, timeout: null, controller: null, data: null, width: null };
		const temperature = {
			range: document.getElementById('temperature-range'),
			scale: document.getElementById('temperature-scale'),
			guide: document.getElementById('temperature-guide'),
			graph: document.getElementById('temperature-graph'),
			label: document.getElementById('temperature-label'),
		};
		const humidity = {
			range: document.getElementById('humidity-range'),
			scale: document.getElementById('humidity-scale'),
			guide: document.getElementById('humidity-guide'),
			graph: document.getElementById('humidity-graph'),
			label: document.getElementById('humidity-label'),
		};
		const photovoltaic = {
			range: document.getElementById('photovoltaic-range'),
			scale: document.getElementById('photovoltaic-scale'),
			guide: document.getElementById('photovoltaic-guide'),
			graph: document.getElementById('photovoltaic-graph'),
			label: document.getElementById('photovoltaic-label'),
		};
		const battery = {
			range: document.getElementById('battery-range'),
			scale: document.getElementById('battery-scale'),
			guide: document.getElementById('battery-guide'),
			graph: document.getElementById('battery-graph'),
			label: document.getElementById('battery-label'),
		};
		const delay = {
			range: document.getElementById('delay-range'),
			scale: document.getElementById('delay-scale'),
			guide: document.getElementById('delay-guide'),
			graph: document.getElementById('delay-graph'),
			label: document.getElementById('delay-label'),
		};
		const level = {
			range: document.getElementById('level-range'),
			scale: document.getElementById('level-scale'),
			guide: document.getElementById('level-guide'),
			graph: document.getElementById('level-graph'),
			label: document.getElementById('level-label'),
		};
		window.addEventListener('resize', () => {
			const temperatureWidth = breakpoint(temperature.graph.clientWidth);
			if (temperatureWidth !== readings.width) {
				readings.width = temperatureWidth;
				const summary = calculateReadings(readings.data, readings.width);
				window.requestAnimationFrame(() => paintTemperature(temperature, readings.width, summary.temperature, summary.capturedAt));
				window.requestAnimationFrame(() => paintHumidity(humidity, readings.width, summary.humidity, summary.capturedAt));
			}
			const photovoltaicWidth = breakpoint(photovoltaic.graph.clientWidth);
			if (photovoltaicWidth !== metrics.width) {
				metrics.width = photovoltaicWidth;
				const summary = calculateMetrics(metrics.data, metrics.width);
				window.requestAnimationFrame(() => paintPhotovoltaic(photovoltaic, metrics.width, summary.photovoltaic, summary.capturedAt));
				window.requestAnimationFrame(() => paintBattery(battery, metrics.width, summary.battery, summary.capturedAt));
			}
		});
		const getFrom = () => {
			return getParam('from', null);
		};
		const getTo = () => {
			return getParam('to', null);
		};
		const getRange = () => {
			const from = getFrom();
			const to = getTo();
			if (from !== null && to !== null) {
				return +to - +from;
			}
			return +getParam('range', 86400);
		};
		const setRange = (range) => {
			setParam('range', range);
		};
		const highlightRange = (range) => {
			array(ranges.children.length).forEach((ind) => {
				if (+ranges.children[ind].getAttribute('value') === range) {
					array(ranges.children[ind].children.length).forEach((i) => {
						ranges.children[ind].children[i].classList.add('text-blue-600', 'dark:text-blue-400');
						ranges.children[ind].children[i].classList.remove('text-black', 'dark:text-white');
					});
				} else {
					array(ranges.children[ind].children.length).forEach((i) => {
						ranges.children[ind].children[i].classList.remove('text-blue-600', 'dark:text-blue-400');
						ranges.children[ind].children[i].classList.add('text-black', 'dark:text-white');
					});
				}
			});
		};
		const paintTimes = (from, to) => {
			if (from === null) {
				times.children[0].value = '';
			} else {
				times.children[0].value = datetime(from);
			}
			if (from === null) {
				times.children[1].value = '';
			} else {
				times.children[1].value = datetime(to);
			}
		};
		if (getFrom() === null && getTo() === null) {
			highlightRange(getRange());
		} else {
			paintTimes(getFrom(), getTo());
		}
		const onRangeChange = (range) => {
			highlightRange(range);
			setRange(range);
			paintTimes(null, null);
			setParam('from', null);
			setParam('to', null);
			loadReadings();
			loadMetrics();
			loadBuffers();
		};
		const onTimeChange = (key, value) => {
			setParam(key, Math.floor(new Date(value).getTime() / 1000));
			if (getFrom() !== null && getTo() !== null) {
				highlightRange(null);
				setRange(null);
				loadReadings();
				loadMetrics();
				loadBuffers();
			}
		};
		const loadingTemperature = (element, width) => {
			array(element.label.children.length).forEach((ind) => {
				loading(element.label.children[ind], ['w-8', 'h-3'], [], '');
			});
			loading(element.range, ['w-28', 'h-4'], []);
			array(element.range.children.length).forEach((ind) => {
				loading(element.range.children[ind], [], [], '');
			});
			array(element.scale.children.length).forEach((ind) => {
				loading(element.scale.children[ind], ['h-3'], [], '');
			});
			loading(element.guide, [], []);
			array(element.guide.children.length).forEach((ind) => {
				element.guide.children[ind].children[0].classList.add('hidden');
				paint(element.guide.children[ind].children[1], [], [], '');
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			array(element.graph.children.length).forEach((ind) => {
				if (ind === 0) {
					element.graph.children[ind].classList.add('stroke-neutral-200', 'dark:stroke-neutral-800');
					element.graph.children[ind].classList.remove('stroke-red-200', 'dark:stroke-red-800');
					const factor = width / (temperatureSkeleton.length - 1);
					const skeleton = temperatureSkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
					element.graph.children[ind].setAttribute('d', skeleton.join(' '));
				} else {
					element.graph.children[ind].removeAttribute('d');
				}
			});
		};
		const paintTemperature = (element, width, temperature, capturedAt) => {
			const interval = (Number(capturedAt.end) - Number(capturedAt.start)) / (element.label.children.length - 1);
			if (capturedAt.start !== null && capturedAt.end !== null) {
				array(element.label.children.length).forEach((ind) => {
					const label = timespan(Number(capturedAt.start) + ind * interval, getRange());
					paint(element.label.children[element.label.children.length - ind - 1], [], ['w-8', 'h-3'], label);
				});
			}
			if (temperature.min.abs !== null && temperature.max.abs !== null) {
				paint(element.range, [], ['w-28', 'h-4']);
				paint(element.range.children[0], [], [], temperature.min.abs.toFixed(2));
				fade(element.range.children[0]);
				colorTemperature(element.range.children[0], temperature.min.abs);
				paint(element.range.children[1], [], [], ' - ');
				paint(element.range.children[2], [], [], temperature.max.abs.toFixed(2));
				fade(element.range.children[2]);
				colorTemperature(element.range.children[2], temperature.max.abs);
			}
			if (temperature.min.floor !== null && temperature.max.ceil !== null) {
				const scaleLength = element.scale.children.length;
				const interval = (temperature.max.ceil - temperature.min.floor) / scaleLength;
				array(scaleLength).forEach((ind) => {
					paint(element.scale.children[scaleLength - 1 - ind], [], ['h-3'], (temperature.min.floor + ind * interval).toFixed(1));
				});
			}
			const devices = Array.from(new Set(temperature.points.map((point) => point.d))).sort();
			const mappings = new Map(devices.map((id, ind) => [id, ind]));
			if (devices.length !== 0) {
				paint(element.guide, [], []);
				array(element.guide.children.length).forEach((ind) => {
					if (ind < devices.length) {
						element.guide.children[ind].children[0].classList.remove('hidden');
						paint(element.guide.children[ind].children[1], [], [], devices[ind].substring(0, 4));
					} else {
						element.guide.children[ind].children[0].classList.add('hidden');
						paint(element.guide.children[ind].children[1], [], [], '');
					}
				});
			}
			temperature.points.forEach((point) => {
				const index = mappings.get(point.d);
				temperature.devices[index].push(point);
			});
			temperature.devices.forEach((points, index) => {
				const distance = width / points.length;
				points.forEach((point, ind) => {
					const last = ind === 0 ? point : points[ind - 1];
					let type = temperature.paths[index + 1].length === 0 ? 'M' : 'L';
					if (last.x - point.x > distance * 8) {
						type = 'M';
					}
					temperature.paths[index + 1].push(`${type} ${point.x.toFixed(2)} ${point.y.toFixed(2)}`);
				});
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			const factor = width / (temperatureSkeleton.length - 1);
			const skeleton = temperatureSkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
			element.graph.children[0].setAttribute('d', skeleton.join(' '));
			if (capturedAt.start !== null && capturedAt.end !== null) {
				temperature.paths.forEach((path, ind) => {
					if (path.length !== 0) {
						element.graph.children[ind].setAttribute('d', path.join(' '));
					} else {
						element.graph.children[ind].removeAttribute('d');
					}
				});
			}
		};
		const errorTemperature = (element, width) => {
			array(element.label.children.length).forEach((ind) => {
				error(element.label.children[ind], ['w-8', 'h-3'], [], '');
			});
			error(element.range, ['w-28', 'h-4'], []);
			array(element.range.children.length).forEach((ind) => {
				error(element.range.children[ind], [], [], '');
			});
			array(element.scale.children.length).forEach((ind) => {
				error(element.scale.children[ind], ['h-3'], [], '');
			});
			error(element.guide, [], []);
			array(element.guide.children.length).forEach((ind) => {
				element.guide.children[ind].children[0].classList.add('hidden');
				paint(element.guide.children[ind].children[1], [], [], '');
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			array(element.graph.children.length).forEach((ind) => {
				if (ind === 0) {
					element.graph.children[ind].classList.add('stroke-red-200', 'dark:stroke-red-800');
					element.graph.children[ind].classList.remove('stroke-neutral-200', 'dark:stroke-neutral-800');
					const factor = width / (temperatureSkeleton.length - 1);
					const skeleton = temperatureSkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
					element.graph.children[ind].setAttribute('d', skeleton.join(' '));
				} else {
					element.graph.children[ind].removeAttribute('d');
				}
			});
		};
		const loadingHumidity = (element, width) => {
			array(element.label.children.length).forEach((ind) => {
				loading(element.label.children[ind], ['w-8', 'h-3'], [], '');
			});
			loading(element.range, ['w-28', 'h-4'], []);
			array(element.range.children.length).forEach((ind) => {
				loading(element.range.children[ind], [], [], '');
			});
			array(element.scale.children.length).forEach((ind) => {
				loading(element.scale.children[ind], ['h-3'], [], '');
			});
			loading(element.guide, [], []);
			array(element.guide.children.length).forEach((ind) => {
				element.guide.children[ind].children[0].classList.add('hidden');
				paint(element.guide.children[ind].children[1], [], [], '');
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			array(element.graph.children.length).forEach((ind) => {
				if (ind === 0) {
					element.graph.children[ind].classList.add('stroke-neutral-200', 'dark:stroke-neutral-800');
					element.graph.children[ind].classList.remove('stroke-red-200', 'dark:stroke-red-800');
					const factor = width / (humiditySkeleton.length - 1);
					const skeleton = humiditySkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
					element.graph.children[ind].setAttribute('d', skeleton.join(' '));
				} else {
					element.graph.children[ind].removeAttribute('d');
				}
			});
		};
		const paintHumidity = (element, width, humidity, capturedAt) => {
			const interval = (Number(capturedAt.end) - Number(capturedAt.start)) / (element.label.children.length - 1);
			if (capturedAt.start !== null && capturedAt.end !== null) {
				array(element.label.children.length).forEach((ind) => {
					const label = timespan(Number(capturedAt.start) + ind * interval, getRange());
					paint(element.label.children[element.label.children.length - ind - 1], [], ['w-8', 'h-3'], label);
				});
			}
			if (humidity.min.abs !== null && humidity.max.abs !== null) {
				paint(element.range, [], ['w-28', 'h-4']);
				paint(element.range.children[0], [], [], humidity.min.abs.toFixed(2));
				fade(element.range.children[0]);
				colorHumidity(element.range.children[0], humidity.min.abs);
				paint(element.range.children[1], [], [], ' - ');
				paint(element.range.children[2], [], [], humidity.max.abs.toFixed(2));
				fade(element.range.children[2]);
				colorHumidity(element.range.children[2], humidity.max.abs);
			}
			if (humidity.min.floor !== null && humidity.max.ceil !== null) {
				const scaleLength = element.scale.children.length;
				const interval = (humidity.max.ceil - humidity.min.floor) / scaleLength;
				array(scaleLength).forEach((ind) => {
					paint(element.scale.children[scaleLength - 1 - ind], [], ['h-3'], (humidity.min.floor + ind * interval).toFixed(1));
				});
			}
			const devices = Array.from(new Set(humidity.points.map((point) => point.d))).sort();
			const mappings = new Map(devices.map((id, ind) => [id, ind]));
			if (devices.length !== 0) {
				paint(element.guide, [], []);
				array(element.guide.children.length).forEach((ind) => {
					if (ind < devices.length) {
						element.guide.children[ind].children[0].classList.remove('hidden');
						paint(element.guide.children[ind].children[1], [], [], devices[ind].substring(0, 4));
					} else {
						element.guide.children[ind].children[0].classList.add('hidden');
						paint(element.guide.children[ind].children[1], [], [], '');
					}
				});
			}
			humidity.points.forEach((point) => {
				const index = mappings.get(point.d);
				humidity.devices[index].push(point);
			});
			humidity.devices.forEach((points, index) => {
				const distance = width / points.length;
				points.forEach((point, ind) => {
					const last = ind === 0 ? point : points[ind - 1];
					let type = humidity.paths[index + 1].length === 0 ? 'M' : 'L';
					if (last.x - point.x > distance * 8) {
						type = 'M';
					}
					humidity.paths[index + 1].push(`${type} ${point.x.toFixed(2)} ${point.y.toFixed(2)}`);
				});
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			const factor = width / (humiditySkeleton.length - 1);
			const skeleton = humiditySkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
			element.graph.children[0].setAttribute('d', skeleton.join(' '));
			if (capturedAt.start !== null && capturedAt.end !== null) {
				humidity.paths.forEach((path, ind) => {
					if (path.length !== 0) {
						element.graph.children[ind].setAttribute('d', path.join(' '));
					} else {
						element.graph.children[ind].removeAttribute('d');
					}
				});
			}
		};
		const errorHumidity = (element, width) => {
			array(element.label.children.length).forEach((ind) => {
				error(element.label.children[ind], ['w-8', 'h-3'], [], '');
			});
			error(element.range, ['w-28', 'h-4'], []);
			array(element.range.children.length).forEach((ind) => {
				error(element.range.children[ind], [], [], '');
			});
			array(element.scale.children.length).forEach((ind) => {
				error(element.scale.children[ind], ['h-3'], [], '');
			});
			error(element.guide, [], []);
			array(element.guide.children.length).forEach((ind) => {
				element.guide.children[ind].children[0].classList.add('hidden');
				paint(element.guide.children[ind].children[1], [], [], '');
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			array(element.graph.children.length).forEach((ind) => {
				if (ind === 0) {
					element.graph.children[ind].classList.add('stroke-red-200', 'dark:stroke-red-800');
					element.graph.children[ind].classList.remove('stroke-neutral-200', 'dark:stroke-neutral-800');
					const factor = width / (humiditySkeleton.length - 1);
					const skeleton = humiditySkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
					element.graph.children[ind].setAttribute('d', skeleton.join(' '));
				} else {
					element.graph.children[ind].removeAttribute('d');
				}
			});
		};
		const loadingPhotovoltaic = (element, width) => {
			array(element.label.children.length).forEach((ind) => {
				loading(element.label.children[ind], ['w-8', 'h-3'], [], '');
			});
			loading(element.range, ['w-28', 'h-4'], []);
			array(element.range.children.length).forEach((ind) => {
				loading(element.range.children[ind], [], [], '');
			});
			array(element.scale.children.length).forEach((ind) => {
				loading(element.scale.children[ind], ['h-3'], [], '');
			});
			loading(element.guide, [], []);
			array(element.guide.children.length).forEach((ind) => {
				element.guide.children[ind].children[0].classList.add('hidden');
				paint(element.guide.children[ind].children[1], [], [], '');
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			array(element.graph.children.length).forEach((ind) => {
				if (ind === 0) {
					element.graph.children[ind].classList.add('stroke-neutral-200', 'dark:stroke-neutral-800');
					element.graph.children[ind].classList.remove('stroke-red-200', 'dark:stroke-red-800');
					const factor = width / (photovoltaicSkeleton.length - 1);
					const skeleton = photovoltaicSkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
					element.graph.children[ind].setAttribute('d', skeleton.join(' '));
				} else {
					element.graph.children[ind].removeAttribute('d');
				}
			});
		};
		const paintPhotovoltaic = (element, width, photovoltaic, capturedAt) => {
			const interval = (Number(capturedAt.end) - Number(capturedAt.start)) / (element.label.children.length - 1);
			if (capturedAt.start !== null && capturedAt.end !== null) {
				array(element.label.children.length).forEach((ind) => {
					const label = timespan(Number(capturedAt.start) + ind * interval, getRange());
					paint(element.label.children[element.label.children.length - ind - 1], [], ['w-8', 'h-3'], label);
				});
			}
			if (photovoltaic.min.abs !== null && photovoltaic.max.abs !== null) {
				paint(element.range, [], ['w-28', 'h-4']);
				paint(element.range.children[0], [], [], photovoltaic.min.abs.toFixed(3));
				fade(element.range.children[0]);
				colorPhotovoltaic(element.range.children[0], photovoltaic.min.abs);
				paint(element.range.children[1], [], [], ' - ');
				paint(element.range.children[2], [], [], photovoltaic.max.abs.toFixed(3));
				fade(element.range.children[2]);
				colorPhotovoltaic(element.range.children[2], photovoltaic.max.abs);
			}
			if (photovoltaic.min.floor !== null && photovoltaic.max.ceil !== null) {
				const scaleLength = element.scale.children.length;
				const interval = (photovoltaic.max.ceil - photovoltaic.min.floor) / scaleLength;
				array(scaleLength).forEach((ind) => {
					paint(element.scale.children[scaleLength - 1 - ind], [], ['h-3'], (photovoltaic.min.floor + ind * interval).toFixed(2));
				});
			}
			const devices = Array.from(new Set(photovoltaic.points.map((point) => point.d))).sort();
			const mappings = new Map(devices.map((id, ind) => [id, ind]));
			if (devices.length !== 0) {
				paint(element.guide, [], []);
				array(element.guide.children.length).forEach((ind) => {
					if (ind < devices.length) {
						element.guide.children[ind].children[0].classList.remove('hidden');
						paint(element.guide.children[ind].children[1], [], [], devices[ind].substring(0, 4));
					} else {
						element.guide.children[ind].children[0].classList.add('hidden');
						paint(element.guide.children[ind].children[1], [], [], '');
					}
				});
			}
			photovoltaic.points.forEach((point) => {
				const index = mappings.get(point.d);
				photovoltaic.devices[index].push(point);
			});
			photovoltaic.devices.forEach((points, index) => {
				const distance = width / points.length;
				points.forEach((point, ind) => {
					const last = ind === 0 ? point : points[ind - 1];
					let type = photovoltaic.paths[index + 1].length === 0 ? 'M' : 'L';
					if (last.x - point.x > distance * 8) {
						type = 'M';
					}
					photovoltaic.paths[index + 1].push(`${type} ${point.x.toFixed(2)} ${point.y.toFixed(2)}`);
				});
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			const factor = width / (photovoltaicSkeleton.length - 1);
			const skeleton = photovoltaicSkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
			element.graph.children[0].setAttribute('d', skeleton.join(' '));
			if (capturedAt.start !== null && capturedAt.end !== null) {
				photovoltaic.paths.forEach((path, ind) => {
					if (path.length !== 0) {
						element.graph.children[ind].setAttribute('d', path.join(' '));
					} else {
						element.graph.children[ind].removeAttribute('d');
					}
				});
			}
		};
		const errorPhotovoltaic = (element, width) => {
			array(element.label.children.length).forEach((ind) => {
				error(element.label.children[ind], ['w-8', 'h-3'], [], '');
			});
			error(element.range, ['w-28', 'h-4'], []);
			array(element.range.children.length).forEach((ind) => {
				error(element.range.children[ind], [], [], '');
			});
			array(element.scale.children.length).forEach((ind) => {
				error(element.scale.children[ind], ['h-3'], [], '');
			});
			error(element.guide, [], []);
			array(element.guide.children.length).forEach((ind) => {
				element.guide.children[ind].children[0].classList.add('hidden');
				paint(element.guide.children[ind].children[1], [], [], '');
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			array(element.graph.children.length).forEach((ind) => {
				if (ind === 0) {
					element.graph.children[ind].classList.add('stroke-red-200', 'dark:stroke-red-800');
					element.graph.children[ind].classList.remove('stroke-neutral-200', 'dark:stroke-neutral-800');
					const factor = width / (photovoltaicSkeleton.length - 1);
					const skeleton = photovoltaicSkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
					element.graph.children[ind].setAttribute('d', skeleton.join(' '));
				} else {
					element.graph.children[ind].removeAttribute('d');
				}
			});
		};
		const loadingBattery = (element, width) => {
			array(element.label.children.length).forEach((ind) => {
				loading(element.label.children[ind], ['w-8', 'h-3'], [], '');
			});
			loading(element.range, ['w-28', 'h-4'], []);
			array(element.range.children.length).forEach((ind) => {
				loading(element.range.children[ind], [], [], '');
			});
			array(element.scale.children.length).forEach((ind) => {
				loading(element.scale.children[ind], ['h-3'], [], '');
			});
			loading(element.guide, [], []);
			array(element.guide.children.length).forEach((ind) => {
				element.guide.children[ind].children[0].classList.add('hidden');
				paint(element.guide.children[ind].children[1], [], [], '');
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			array(element.graph.children.length).forEach((ind) => {
				if (ind === 0) {
					element.graph.children[ind].classList.add('stroke-neutral-200', 'dark:stroke-neutral-800');
					element.graph.children[ind].classList.remove('stroke-red-200', 'dark:stroke-red-800');
					const factor = width / (batterySkeleton.length - 1);
					const skeleton = batterySkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
					element.graph.children[ind].setAttribute('d', skeleton.join(' '));
				} else {
					element.graph.children[ind].removeAttribute('d');
				}
			});
		};
		const paintBattery = (element, width, battery, capturedAt) => {
			const interval = (Number(capturedAt.end) - Number(capturedAt.start)) / (element.label.children.length - 1);
			if (capturedAt.start !== null && capturedAt.end !== null) {
				array(element.label.children.length).forEach((ind) => {
					const label = timespan(Number(capturedAt.start) + ind * interval, getRange());
					paint(element.label.children[element.label.children.length - ind - 1], [], ['w-8', 'h-3'], label);
				});
			}
			if (battery.min.abs !== null && battery.max.abs !== null) {
				paint(element.range, [], ['w-28', 'h-4']);
				paint(element.range.children[0], [], [], battery.min.abs.toFixed(3));
				fade(element.range.children[0]);
				colorBattery(element.range.children[0], battery.min.abs);
				paint(element.range.children[1], [], [], ' - ');
				paint(element.range.children[2], [], [], battery.max.abs.toFixed(3));
				fade(element.range.children[2]);
				colorBattery(element.range.children[2], battery.max.abs);
			}
			if (battery.min.floor !== null && battery.max.ceil !== null) {
				const scaleLength = element.scale.children.length;
				const interval = (battery.max.ceil - battery.min.floor) / scaleLength;
				array(scaleLength).forEach((ind) => {
					paint(element.scale.children[scaleLength - 1 - ind], [], ['h-3'], (battery.min.floor + ind * interval).toFixed(2));
				});
			}
			const devices = Array.from(new Set(battery.points.map((point) => point.d))).sort();
			const mappings = new Map(devices.map((id, ind) => [id, ind]));
			if (devices.length !== 0) {
				paint(element.guide, [], []);
				array(element.guide.children.length).forEach((ind) => {
					if (ind < devices.length) {
						element.guide.children[ind].children[0].classList.remove('hidden');
						paint(element.guide.children[ind].children[1], [], [], devices[ind].substring(0, 4));
					} else {
						element.guide.children[ind].children[0].classList.add('hidden');
						paint(element.guide.children[ind].children[1], [], [], '');
					}
				});
			}
			battery.points.forEach((point) => {
				const index = mappings.get(point.d);
				battery.devices[index].push(point);
			});
			battery.devices.forEach((points, index) => {
				const distance = width / points.length;
				points.forEach((point, ind) => {
					const last = ind === 0 ? point : points[ind - 1];
					let type = battery.paths[index + 1].length === 0 ? 'M' : 'L';
					if (last.x - point.x > distance * 8) {
						type = 'M';
					}
					battery.paths[index + 1].push(`${type} ${point.x.toFixed(2)} ${point.y.toFixed(2)}`);
				});
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			const factor = width / (batterySkeleton.length - 1);
			const skeleton = batterySkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
			element.graph.children[0].setAttribute('d', skeleton.join(' '));
			if (capturedAt.start !== null && capturedAt.end !== null) {
				battery.paths.forEach((path, ind) => {
					if (path.length !== 0) {
						element.graph.children[ind].setAttribute('d', path.join(' '));
					} else {
						element.graph.children[ind].removeAttribute('d');
					}
				});
			}
		};
		const errorBattery = (element, width) => {
			array(element.label.children.length).forEach((ind) => {
				error(element.label.children[ind], ['w-8', 'h-3'], [], '');
			});
			error(element.range, ['w-28', 'h-4'], []);
			array(element.range.children.length).forEach((ind) => {
				error(element.range.children[ind], [], [], '');
			});
			array(element.scale.children.length).forEach((ind) => {
				error(element.scale.children[ind], ['h-3'], [], '');
			});
			error(element.guide, [], []);
			array(element.guide.children.length).forEach((ind) => {
				element.guide.children[ind].children[0].classList.add('hidden');
				paint(element.guide.children[ind].children[1], [], [], '');
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			array(element.graph.children.length).forEach((ind) => {
				if (ind === 0) {
					element.graph.children[ind].classList.add('stroke-red-200', 'dark:stroke-red-800');
					element.graph.children[ind].classList.remove('stroke-neutral-200', 'dark:stroke-neutral-800');
					const factor = width / (batterySkeleton.length - 1);
					const skeleton = batterySkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
					element.graph.children[ind].setAttribute('d', skeleton.join(' '));
				} else {
					element.graph.children[ind].removeAttribute('d');
				}
			});
		};
		const loadingDelay = (element, width) => {
			array(element.label.children.length).forEach((ind) => {
				loading(element.label.children[ind], ['w-8', 'h-3'], [], '');
			});
			loading(element.range, ['w-28', 'h-4'], []);
			array(element.range.children.length).forEach((ind) => {
				loading(element.range.children[ind], [], [], '');
			});
			array(element.scale.children.length).forEach((ind) => {
				loading(element.scale.children[ind], ['h-3'], [], '');
			});
			loading(element.guide, [], []);
			array(element.guide.children.length).forEach((ind) => {
				element.guide.children[ind].children[0].classList.add('hidden');
				paint(element.guide.children[ind].children[1], [], [], '');
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			array(element.graph.children.length).forEach((ind) => {
				if (ind === 0) {
					element.graph.children[ind].classList.add('stroke-neutral-200', 'dark:stroke-neutral-800');
					element.graph.children[ind].classList.remove('stroke-red-200', 'dark:stroke-red-800');
					const factor = width / (delaySkeleton.length - 1);
					const skeleton = delaySkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
					element.graph.children[ind].setAttribute('d', skeleton.join(' '));
				} else {
					element.graph.children[ind].removeAttribute('d');
				}
			});
		};
		const paintDelay = (element, width, delay, capturedAt) => {
			const interval = (Number(capturedAt.end) - Number(capturedAt.start)) / (element.label.children.length - 1);
			if (capturedAt.start !== null && capturedAt.end !== null) {
				array(element.label.children.length).forEach((ind) => {
					const label = timespan(Number(capturedAt.start) + ind * interval, getRange());
					paint(element.label.children[element.label.children.length - ind - 1], [], ['w-8', 'h-3'], label);
				});
			}
			if (delay.min.abs !== null && delay.max.abs !== null) {
				paint(element.range, [], ['w-28', 'h-4']);
				paint(element.range.children[0], [], [], duration(delay.min.abs));
				fade(element.range.children[0]);
				colorDelay(element.range.children[0], delay.min.abs);
				paint(element.range.children[1], [], [], ' - ');
				paint(element.range.children[2], [], [], duration(delay.max.abs));
				fade(element.range.children[2]);
				colorDelay(element.range.children[2], delay.max.abs);
			}
			if (delay.min.floor !== null && delay.max.ceil !== null) {
				const scaleLength = element.scale.children.length;
				const interval = (delay.max.ceil - delay.min.floor) / scaleLength;
				array(scaleLength).forEach((ind) => {
					paint(element.scale.children[scaleLength - 1 - ind], [], ['h-3'], duration(delay.min.floor + ind * interval));
				});
			}
			const devices = Array.from(new Set(delay.points.map((point) => point.d))).sort();
			const mappings = new Map(devices.map((id, ind) => [id, ind]));
			if (devices.length !== 0) {
				paint(element.guide, [], []);
				array(element.guide.children.length).forEach((ind) => {
					if (ind < devices.length) {
						element.guide.children[ind].children[0].classList.remove('hidden');
						paint(element.guide.children[ind].children[1], [], [], devices[ind].substring(0, 4));
					} else {
						element.guide.children[ind].children[0].classList.add('hidden');
						paint(element.guide.children[ind].children[1], [], [], '');
					}
				});
			}
			delay.points.forEach((point) => {
				const index = mappings.get(point.d);
				delay.devices[index].push(point);
			});
			delay.devices.forEach((points, index) => {
				const distance = width / points.length;
				points.forEach((point, ind) => {
					const last = ind === 0 ? point : points[ind - 1];
					let type = delay.paths[index + 1].length === 0 ? 'M' : 'L';
					delay.paths[index + 1].push(`${type} ${point.x.toFixed(2)} ${point.y.toFixed(2)}`);
				});
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			const factor = width / (delaySkeleton.length - 1);
			const skeleton = delaySkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
			element.graph.children[0].setAttribute('d', skeleton.join(' '));
			if (capturedAt.start !== null && capturedAt.end !== null) {
				delay.paths.forEach((path, ind) => {
					if (path.length !== 0) {
						element.graph.children[ind].setAttribute('d', path.join(' '));
					} else {
						element.graph.children[ind].removeAttribute('d');
					}
				});
			}
		};
		const errorDelay = (element, width) => {
			array(element.label.children.length).forEach((ind) => {
				error(element.label.children[ind], ['w-8', 'h-3'], [], '');
			});
			error(element.range, ['w-28', 'h-4'], []);
			array(element.range.children.length).forEach((ind) => {
				error(element.range.children[ind], [], [], '');
			});
			array(element.scale.children.length).forEach((ind) => {
				error(element.scale.children[ind], ['h-3'], [], '');
			});
			error(element.guide, [], []);
			array(element.guide.children.length).forEach((ind) => {
				element.guide.children[ind].children[0].classList.add('hidden');
				paint(element.guide.children[ind].children[1], [], [], '');
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			array(element.graph.children.length).forEach((ind) => {
				if (ind === 0) {
					element.graph.children[ind].classList.add('stroke-red-200', 'dark:stroke-red-800');
					element.graph.children[ind].classList.remove('stroke-neutral-200', 'dark:stroke-neutral-800');
					const factor = width / (delaySkeleton.length - 1);
					const skeleton = delaySkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
					element.graph.children[ind].setAttribute('d', skeleton.join(' '));
				} else {
					element.graph.children[ind].removeAttribute('d');
				}
			});
		};
		const loadingLevel = (element, width) => {
			array(element.label.children.length).forEach((ind) => {
				loading(element.label.children[ind], ['w-8', 'h-3'], [], '');
			});
			loading(element.range, ['w-28', 'h-4'], []);
			array(element.range.children.length).forEach((ind) => {
				loading(element.range.children[ind], [], [], '');
			});
			array(element.scale.children.length).forEach((ind) => {
				loading(element.scale.children[ind], ['h-3'], [], '');
			});
			loading(element.guide, [], []);
			array(element.guide.children.length).forEach((ind) => {
				element.guide.children[ind].children[0].classList.add('hidden');
				paint(element.guide.children[ind].children[1], [], [], '');
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			array(element.graph.children.length).forEach((ind) => {
				if (ind === 0) {
					element.graph.children[ind].classList.add('stroke-neutral-200', 'dark:stroke-neutral-800');
					element.graph.children[ind].classList.remove('stroke-red-200', 'dark:stroke-red-800');
					const factor = width / (levelSkeleton.length - 1);
					const skeleton = levelSkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
					element.graph.children[ind].setAttribute('d', skeleton.join(' '));
				} else {
					element.graph.children[ind].removeAttribute('d');
				}
			});
		};
		const paintLevel = (element, width, level, capturedAt) => {
			const interval = (Number(capturedAt.end) - Number(capturedAt.start)) / (element.label.children.length - 1);
			if (capturedAt.start !== null && capturedAt.end !== null) {
				array(element.label.children.length).forEach((ind) => {
					const label = timespan(Number(capturedAt.start) + ind * interval, getRange());
					paint(element.label.children[element.label.children.length - ind - 1], [], ['w-8', 'h-3'], label);
				});
			}
			if (level.min.abs !== null && level.max.abs !== null) {
				paint(element.range, [], ['w-28', 'h-4']);
				paint(element.range.children[0], [], [], level.min.abs.toFixed(0));
				fade(element.range.children[0]);
				colorLevel(element.range.children[0], level.min.abs);
				paint(element.range.children[1], [], [], ' - ');
				paint(element.range.children[2], [], [], level.max.abs.toFixed(0));
				fade(element.range.children[2]);
				colorLevel(element.range.children[2], level.max.abs);
			}
			if (level.min.floor !== null && level.max.ceil !== null) {
				const scaleLength = element.scale.children.length;
				const interval = (level.max.ceil - level.min.floor) / scaleLength;
				array(scaleLength).forEach((ind) => {
					paint(element.scale.children[scaleLength - 1 - ind], [], ['h-3'], (level.min.floor + ind * interval).toFixed(0));
				});
			}
			const devices = Array.from(new Set(level.points.map((point) => point.d))).sort();
			const mappings = new Map(devices.map((id, ind) => [id, ind]));
			if (devices.length !== 0) {
				paint(element.guide, [], []);
				array(element.guide.children.length).forEach((ind) => {
					if (ind < devices.length) {
						element.guide.children[ind].children[0].classList.remove('hidden');
						paint(element.guide.children[ind].children[1], [], [], devices[ind].substring(0, 4));
					} else {
						element.guide.children[ind].children[0].classList.add('hidden');
						paint(element.guide.children[ind].children[1], [], [], '');
					}
				});
			}
			level.points.forEach((point) => {
				const index = mappings.get(point.d);
				level.devices[index].push(point);
			});
			level.devices.forEach((points, index) => {
				const distance = width / points.length;
				points.forEach((point, ind) => {
					const last = ind === 0 ? point : points[ind - 1];
					let type = level.paths[index + 1].length === 0 ? 'M' : 'L';
					level.paths[index + 1].push(`${type} ${point.x.toFixed(2)} ${point.y.toFixed(2)}`);
				});
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			const factor = width / (levelSkeleton.length - 1);
			const skeleton = levelSkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
			element.graph.children[0].setAttribute('d', skeleton.join(' '));
			if (capturedAt.start !== null && capturedAt.end !== null) {
				level.paths.forEach((path, ind) => {
					if (path.length !== 0) {
						element.graph.children[ind].setAttribute('d', path.join(' '));
					} else {
						element.graph.children[ind].removeAttribute('d');
					}
				});
			}
		};
		const errorLevel = (element, width) => {
			array(element.label.children.length).forEach((ind) => {
				error(element.label.children[ind], ['w-8', 'h-3'], [], '');
			});
			error(element.range, ['w-28', 'h-4'], []);
			array(element.range.children.length).forEach((ind) => {
				error(element.range.children[ind], [], [], '');
			});
			array(element.scale.children.length).forEach((ind) => {
				error(element.scale.children[ind], ['h-3'], [], '');
			});
			error(element.guide, [], []);
			array(element.guide.children.length).forEach((ind) => {
				element.guide.children[ind].children[0].classList.add('hidden');
				paint(element.guide.children[ind].children[1], [], [], '');
			});
			element.graph.setAttribute('viewBox', `0 0 ${width} 100`);
			array(element.graph.children.length).forEach((ind) => {
				if (ind === 0) {
					element.graph.children[ind].classList.add('stroke-red-200', 'dark:stroke-red-800');
					element.graph.children[ind].classList.remove('stroke-neutral-200', 'dark:stroke-neutral-800');
					const factor = width / (levelSkeleton.length - 1);
					const skeleton = levelSkeleton.map((value, ind) => `${ind === 0 ? 'M' : 'L'} ${(ind * factor).toFixed(2)} ${value}`);
					element.graph.children[ind].setAttribute('d', skeleton.join(' '));
				} else {
					element.graph.children[ind].removeAttribute('d');
				}
			});
		};
		const calculateReadings = (data, width) => {
			const readings = {
				temperature: {
					min: { abs: null, floor: null },
					max: { abs: null, ceil: null },
					points: [],
					devices: array(temperature.guide.children.length).map(() => []),
					paths: array(temperature.graph.children.length).map(() => []),
				},
				humidity: {
					min: { abs: null, floor: null },
					max: { abs: null, ceil: null },
					points: [],
					devices: array(humidity.guide.children.length).map(() => []),
					paths: array(humidity.graph.children.length).map(() => []),
				},
				capturedAt: { start: null, end: null },
			};
			if (data !== null) {
				const from = getFrom();
				const to = getTo();
				if (from !== null || to !== null) {
					readings.capturedAt.start = +to;
					readings.capturedAt.end = +from;
				} else {
					readings.capturedAt.start = Math.floor(Date.now() / 1000);
					readings.capturedAt.end = Math.floor(Date.now() / 1000 - getRange());
				}
				envelope(readings, data, 'temperature');
				envelope(readings, data, 'humidity');
				coordinate(readings, data, 'temperature', 'capturedAt', width);
				coordinate(readings, data, 'humidity', 'capturedAt', width);
			}
			return readings;
		};
		const parseReadings = async (response) => {
			const buffer = await response.arrayBuffer();
			const binary = new Binary(buffer);
			const readings = [];
			while (binary.offset < buffer.byteLength) {
				const deviceId = binary.uuid();
				const length = binary.uint(16);
				for (let ind = 0; ind < length; ind++) {
					const reading = { temperature: null, humidity: null, capturedAt: null, device: null };
					reading.temperature = binary.int(16) / 100;
					reading.humidity = binary.uint(16) / 100;
					reading.capturedAt = binary.uint(64);
					reading.device = {};
					reading.device.id = deviceId;
					readings.push(reading);
				}
			}
			return readings;
		};
		const calculateMetrics = (data, width) => {
			const metrics = {
				photovoltaic: {
					min: { abs: null, floor: null },
					max: { abs: null, ceil: null },
					points: [],
					devices: array(photovoltaic.guide.children.length).map(() => []),
					paths: array(photovoltaic.graph.children.length).map(() => []),
				},
				battery: {
					min: { abs: null, floor: null },
					max: { abs: null, ceil: null },
					points: [],
					devices: array(battery.guide.children.length).map(() => []),
					paths: array(battery.graph.children.length).map(() => []),
				},
				capturedAt: { start: null, end: null },
			};
			if (data !== null) {
				const from = getFrom();
				const to = getTo();
				if (from !== null || to !== null) {
					metrics.capturedAt.start = +to;
					metrics.capturedAt.end = +from;
				} else {
					metrics.capturedAt.start = Math.floor(Date.now() / 1000);
					metrics.capturedAt.end = Math.floor(Date.now() / 1000 - getRange());
				}
				envelope(metrics, data, 'photovoltaic');
				envelope(metrics, data, 'battery');
				coordinate(metrics, data, 'photovoltaic', 'capturedAt', width);
				coordinate(metrics, data, 'battery', 'capturedAt', width);
			}
			return metrics;
		};
		const parseMetrics = async (response) => {
			const buffer = await response.arrayBuffer();
			const binary = new Binary(buffer);
			const metrics = [];
			while (binary.offset < buffer.byteLength) {
				const deviceId = binary.uuid();
				const length = binary.uint(16);
				for (let ind = 0; ind < length; ind++) {
					const metric = { photovoltaic: null, battery: null, capturedAt: null, device: null };
					metric.photovoltaic = binary.uint(16) / 1000;
					metric.battery = binary.uint(16) / 1000;
					metric.capturedAt = binary.uint(64);
					metric.device = {};
					metric.device.id = deviceId;
					metrics.push(metric);
				}
			}
			return metrics;
		};
		const calculateBuffers = (data, width) => {
			const buffers = {
				delay: {
					min: { abs: null, floor: null },
					max: { abs: null, ceil: null },
					points: [],
					devices: array(delay.guide.children.length).map(() => []),
					paths: array(delay.graph.children.length).map(() => []),
				},
				level: {
					min: { abs: null, floor: null },
					max: { abs: null, ceil: null },
					points: [],
					devices: array(level.guide.children.length).map(() => []),
					paths: array(level.graph.children.length).map(() => []),
				},
				capturedAt: { start: null, end: null },
			};
			if (data !== null) {
				const from = getFrom();
				const to = getTo();
				if (from !== null || to !== null) {
					buffers.capturedAt.start = +to;
					buffers.capturedAt.end = +from;
				} else {
					buffers.capturedAt.start = Math.floor(Date.now() / 1000);
					buffers.capturedAt.end = Math.floor(Date.now() / 1000 - getRange());
				}
				envelope(buffers, data, 'delay');
				envelope(buffers, data, 'level');
				coordinate(buffers, data, 'delay', 'capturedAt', width);
				coordinate(buffers, data, 'level', 'capturedAt', width);
			}
			return buffers;
		};
		const parseBuffers = async (response) => {
			const buffer = await response.arrayBuffer();
			const binary = new Binary(buffer);
			const buffers = [];
			while (binary.offset < buffer.byteLength) {
				const deviceId = binary.uuid();
				const length = binary.uint(16);
				for (let ind = 0; ind < length; ind++) {
					const buffer = { delay: null, level: null, capturedAt: null, device: null };
					buffer.delay = binary.uint(32);
					buffer.level = binary.uint(16);
					buffer.capturedAt = binary.uint(64);
					buffer.device = {};
					buffer.device.id = deviceId;
					buffers.push(buffer);
				}
			}
			return buffers;
		};
		const loadReadings = fetching(
			readings,
			(context) => {
				context.width = breakpoint(temperature.graph.clientWidth);
				window.requestAnimationFrame(() => loadingTemperature(temperature, context.width));
				window.requestAnimationFrame(() => loadingHumidity(humidity, context.width));
			},
			(context) => {
				let from = getFrom();
				let to = getTo();
				if (from === null || to === null) {
					context.reload = getRange() / 360;
					from = Math.floor(Date.now() / 1000) - getRange();
					to = Math.floor(Date.now() / 1000);
				}
				const endpoint = `/api/readings?from=${from}&to=${to}`;
				return fetcher('get', endpoint, null, { controller: context.controller });
			},
			async (context, response) => (context.data = await parseReadings(response)),
			(context) => {
				const summary = calculateReadings(context.data, context.width);
				window.requestAnimationFrame(() => paintTemperature(temperature, context.width, summary.temperature, summary.capturedAt));
				window.requestAnimationFrame(() => paintHumidity(humidity, context.width, summary.humidity, summary.capturedAt));
				if (getFrom() === null || getTo() === null) {
					highlightRange(getRange());
				}
			},
			(context) => {
				window.requestAnimationFrame(() => errorTemperature(temperature, context.width));
				window.requestAnimationFrame(() => errorHumidity(humidity, context.width));
			},
		);
		const loadMetrics = fetching(
			metrics,
			(context) => {
				context.width = breakpoint(photovoltaic.graph.clientWidth);
				window.requestAnimationFrame(() => loadingPhotovoltaic(photovoltaic, context.width));
				window.requestAnimationFrame(() => loadingBattery(battery, context.width));
			},
			(context) => {
				let from = getFrom();
				let to = getTo();
				if (from === null || to === null) {
					context.reload = getRange() / 360;
					from = Math.floor(Date.now() / 1000) - getRange();
					to = Math.floor(Date.now() / 1000);
				}
				const endpoint = `/api/metrics?from=${from}&to=${to}`;
				return fetcher('get', endpoint, null, { controller: context.controller });
			},
			async (context, response) => (context.data = await parseMetrics(response)),
			(context) => {
				const summary = calculateMetrics(context.data, context.width);
				window.requestAnimationFrame(() => paintPhotovoltaic(photovoltaic, context.width, summary.photovoltaic, summary.capturedAt));
				window.requestAnimationFrame(() => paintBattery(battery, context.width, summary.battery, summary.capturedAt));
				if (getFrom() === null || getTo() === null) {
					highlightRange(getRange());
				}
			},
			(context) => {
				window.requestAnimationFrame(() => errorPhotovoltaic(photovoltaic, context.width));
				window.requestAnimationFrame(() => errorBattery(battery, context.width));
			},
		);
		const loadBuffers = fetching(
			buffers,
			(context) => {
				context.width = breakpoint(delay.graph.clientWidth);
				window.requestAnimationFrame(() => loadingDelay(delay, context.width));
				window.requestAnimationFrame(() => loadingLevel(level, context.width));
			},
			(context) => {
				let from = getFrom();
				let to = getTo();
				if (from === null || to === null) {
					context.reload = getRange() / 360;
					from = Math.floor(Date.now() / 1000) - getRange();
					to = Math.floor(Date.now() / 1000);
				}
				const endpoint = `/api/buffers?from=${from}&to=${to}`;
				return fetcher('get', endpoint, null, { controller: context.controller });
			},
			async (context, response) => (context.data = await parseBuffers(response)),
			(context) => {
				const summary = calculateBuffers(context.data, context.width);
				window.requestAnimationFrame(() => paintDelay(delay, context.width, summary.delay, summary.capturedAt));
				window.requestAnimationFrame(() => paintLevel(level, context.width, summary.level, summary.capturedAt));
				if (getFrom() === null || getTo() === null) {
					highlightRange(getRange());
				}
			},
			(context) => {
				window.requestAnimationFrame(() => errorDelay(delay, context.width));
				window.requestAnimationFrame(() => errorLevel(level, context.width));
			},
		);
	</script>
</html>
